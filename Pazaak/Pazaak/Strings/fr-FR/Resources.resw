<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="bckBtn.Content" xml:space="preserve">
    <value>Arrière</value>
  </data>
  <data name="easyBtn.Content" xml:space="preserve">
    <value>Facile </value>
  </data>
  <data name="enBlk.Text" xml:space="preserve">
    <value>AI</value>
  </data>
  <data name="endTurnTxt.Text" xml:space="preserve">
    <value>Fin Du Tour</value>
  </data>
  <data name="enScr.Text" xml:space="preserve">
    <value>Score</value>
  </data>
  <data name="hrdBtn.Content" xml:space="preserve">
    <value>Difficile</value>
  </data>
  <data name="medBtn.Content" xml:space="preserve">
    <value>Moyen</value>
  </data>
  <data name="menuStartGame.Content" xml:space="preserve">
    <value>Démarrer</value>
  </data>
  <data name="settingsBtn.Content" xml:space="preserve">
    <value>Paramètres</value>
  </data>
  <data name="standTxt.Text" xml:space="preserve">
    <value>Servi</value>
  </data>
  <data name="txtDiff.Text" xml:space="preserve">
    <value>Difficulté</value>
  </data>
  <data name="usrBlk.Text" xml:space="preserve">
    <value>Joueur</value>
  </data>
  <data name="usrScr.Text" xml:space="preserve">
    <value>Score</value>
  </data>
  <data name="bust" xml:space="preserve">
    <value>Perdu</value>
  </data>
  <data name="cancel" xml:space="preserve">
    <value>Annuler</value>
  </data>
  <data name="lost" xml:space="preserve">
    <value>Perdu</value>
  </data>
  <data name="newGm" xml:space="preserve">
    <value>encore?</value>
  </data>
  <data name="ok" xml:space="preserve">
    <value>Oui</value>
  </data>
  <data name="tie" xml:space="preserve">
    <value>Ils ont fait match nul</value>
  </data>
  <data name="win" xml:space="preserve">
    <value>Tu as gagné</value>
  </data>
  <data name="instructions.Text" xml:space="preserve">
    <value>Règles :
Conditions de victoire : La valeur cumulée de vos cartes retournées doit être supérieure à celle de votre adversaire, sans pour autant excéder un total de
20. Lorsque l'un des deux joueurs obtient un total supérieur à 20, il perd automatiquement la manche. Il faut remporter un total de trois manches pour
empocher la mise.
Débuter la partie : Lorsque la partie commence, quatre cartes du paquet secondaire sont tirées aléatoirement pour former la main du joueur pendant la
partie.
Le premier joueur lance le générateur de pazaak qui définit une carte principale (de la pioche) et la pose sur la table face visible, ce qui débute son tour.
La valeur des cartes de la pioche est comprise entre 1 et 10 avec des disponibilités variables et aléatoires elles aussi. C’est automatique.
Après que chaque carte est jouée, une carte supplémentaire peut être jouée en faisant glisser la carte vers la zone où les cartes jaunes (principales) déjà
jouées sont affichées.
Vous n’êtes pas obligé de jouer une carte sortie de la MAIN. Cette action est optionnelle.
Vous ne pouvez jouer qu’une carte de la main par tour.
Fin d’un tour : Quand le joueur a fini de jouer, il dit FIN DU TOUR pour permettre à ses adversaires de prendre la main. Cela continue jusqu’à ce que
quelqu’un remporte la manche. Les égalités ne comptent pas. Les cartes de la main du joueur ne peuvent être utilisées qu’une fois, les quatre cartes
doivent donc durer toute la partie.
20 : Si un personnage obtient 20, il s’arrête là et n’est plus distribué. Le jeu continue pendant un tour ou plusieurs tours pour son adversaire (= 1 carte
principale + 1 carte secondaire optionnelle à jouer à chaque tour) qui semble alors jouer seul pour tenter de l’égaler ou perdre.
Servi : Un personnage approchant de 20 (ex : 18) peut choisir d’en rester là, il dit alors SERVI et n’est plus distribué. Le jeu continue pendant un tour ou
plusieurs tours pour son adversaire qui doit tenter de l’égaler ou de le dépasser
sans aller au-delà de 20.
Astuce : Si le total est supérieur à 20 après le tirage principal et que vous avez une carte négative dans le paquet secondaire, vous pouvez la jouer pour
ramener votre total sous 20</value>
  </data>
  <data name="instructionsBtn.Content" xml:space="preserve">
    <value>Mode d'emploi</value>
  </data>
</root>